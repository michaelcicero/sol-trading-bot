#!/usr/bin/env python3
import os
import logging
import asyncio
import aiohttp
import base58
import base64
import random
import json
import websockets
import time
import numpy as np
from datetime import datetime, timedelta
from collections import deque
from dotenv import load_dotenv
from nacl.signing import SigningKey
from solders.signature import Signature
from solders.keypair import Keypair
from solders.pubkey import Pubkey
from solders.transaction import VersionedTransaction
from solders.message import to_bytes_versioned
from solana.rpc.async_api import AsyncClient
from solana.rpc.commitment import Confirmed
from solana.rpc.types import TxOpts, TokenAccountOpts
from spl.token.instructions import create_associated_token_account, get_associated_token_address
from prometheus_client import start_http_server, Gauge, Counter

load_dotenv()

# Configuration
SOL_MINT = "So11111111111111111111111111111111111111112"
TARGET_MINT = "7GCihgDB8fe6KNjn2MYtkzZcRjQy3t9GHdC8uHYmW2hr"
TOKEN_DECIMALS = 9
TOKEN_SYMBOL = "POPCAT"
RSI_PERIOD = 14
RSI_OVERBOUGHT = 70
RSI_OVERSOLD = 30
MAX_REASONABLE_PRICE = 0.1
MIN_SOL_BALANCE = 0.2
MIN_TOKEN_RECEIVED = 100_000_000
TRADE_COOLDOWN = 60  # seconds
RISK_PER_TRADE = 0.3  # 30% of balance
SELL_PERCENTAGE = 0.9  # 90% of position

HELIUS_WS_URL = f"wss://mainnet.helius-rpc.com/?api-key={os.getenv('HELIUS_API_KEY')}"
JUPITER_API_BASE = "https://quote-api.jup.ag/v6"

class HealthMonitor:
    def __init__(self):
        self.last_success = time.monotonic()
        self.consecutive_errors = 0
        self.daily_pnl = 0.0
        self.MAX_DAILY_LOSS = -0.1
        self.last_daily_reset = datetime.now().date()
    
    async def check_health(self):
        if time.monotonic() - self.last_success > 600:
            logging.critical("ðŸ†˜ No successful trades in 10 minutes!")
        self.last_success = time.monotonic()
    
    def record_error(self):
        self.consecutive_errors += 1
        if self.consecutive_errors > 5:
            logging.error("ðŸš¨ Consecutive error threshold exceeded!")
        
    def reset_error_count(self):
        self.consecutive_errors = 0
        
    def reset_daily_pnl(self):
        current_date = datetime.now().date()
        if current_date != self.last_daily_reset:
            self.daily_pnl = 0.0
            self.last_daily_reset = current_date
            return True
        return False

class RSITrader:
    def __init__(self):
        self._validate_environment()
        self._setup_solana_client()
        self._setup_state_management()
        self._setup_prometheus()
        
        self.session = aiohttp.ClientSession(
            connector=aiohttp.TCPConnector(ssl=True, limit=50),
            timeout=aiohttp.ClientTimeout(total=30, connect=10),
            headers={'User-Agent': 'TradingBot/1.0'},
            raise_for_status=True
        )
        
        logging.info(f"ðŸ”‘ Trading Wallet: {self.wallet}")
        logging.info(f"ðŸ”— Helius Endpoint: {self.client._provider.endpoint_uri}")

    def _validate_environment(self):
        required_vars = ['PRIVATE_KEY', 'HELIUS_API_KEY']
        missing = [var for var in required_vars if not os.getenv(var)]
        if missing:
            raise ValueError(f"Missing required environment variables: {', '.join(missing)}")
        self.base58_private_key = os.getenv("PRIVATE_KEY")
        if len(self.base58_private_key) < 40:
            raise ValueError("Invalid PRIVATE_KEY format - must be base58 encoded")

    def _setup_solana_client(self):
        try:
            self.keypair = Keypair.from_base58_string(self.base58_private_key)
            self.wallet = str(self.keypair.pubkey())
            self.client = AsyncClient(
                f"https://mainnet.helius-rpc.com/?api-key={os.getenv('HELIUS_API_KEY')}",
                timeout=30,
                commitment=Confirmed
            )
        except Exception as e:
            logging.critical(f"Failed to initialize Solana client: {e}")
            raise

    def _setup_state_management(self):
        self.price_history = deque(maxlen=100)
        self.current_price = None
        self.balance_cache = {'sol': 0.0, 'token': 0.0}
        self.rsi_cache = (None, datetime.min)  # (value, timestamp)
        self.fifo_queue = deque()
        self.total_invested_sol = 0.0
        self.total_popcat_bought = 0.0
        self.last_trade = datetime.min
        self.price_update_event = asyncio.Event()
        self.last_ws_update = datetime.now()
        self.price_lock = asyncio.Lock()
        self.balance_lock = asyncio.Lock()
        self.trade_lock = asyncio.Lock()
        self.health_monitor = HealthMonitor()

    def _setup_prometheus(self):
        self.sol_balance_gauge = Gauge('sol_balance', 'Current SOL balance')
        self.popcat_balance_gauge = Gauge('popcat_balance', 'Current POPCAT balance')
        self.popcat_price_gauge = Gauge('popcat_price', 'Current POPCAT price')
        self.rsi_gauge = Gauge('rsi', 'Current RSI value')
        self.trade_count = Counter('trade_count_total', 'Total number of trades', ['direction'])
        self.realized_pnl = Counter('realized_pnl_total', 'Total realized PnL in SOL')
        self.unrealized_pnl = Gauge('unrealized_pnl', 'Current unrealized PnL')
        start_http_server(8000)

    async def update_metrics(self):
        self.sol_balance_gauge.set(self.balance_cache['sol'])
        self.popcat_balance_gauge.set(self.balance_cache['token'])
        if self.current_price:
            self.popcat_price_gauge.set(self.current_price)
        if self.rsi_cache[0] is not None:
            self.rsi_gauge.set(self.rsi_cache[0])
        if self.total_popcat_bought > 0 and self.current_price:
            unrealized = (self.current_price * self.total_popcat_bought) - self.total_invested_sol
            self.unrealized_pnl.set(unrealized)

    async def listen_for_price_updates(self):
        reconnect_delay = 1
        max_reconnect_delay = 60
        while True:
            try:
                async with websockets.connect(
                    HELIUS_WS_URL,
                    ping_interval=20,
                    ping_timeout=20,
                    close_timeout=10,
                    extra_headers={"User-Agent": "Mozilla/5.0"}
                ) as ws:
                    logging.info("âœ… WebSocket connected")
                    reconnect_delay = 1
                    subscribe_msg = {
                        "jsonrpc": "2.0",
                        "id": 1,
                        "method": "transactionSubscribe",
                        "params": [
                            {"mentions": [f"token:{TARGET_MINT}"]},
                            {"commitment": "confirmed", "encoding": "jsonParsed"}
                        ]
                    }
                    await ws.send(json.dumps(subscribe_msg))
                    await ws.recv()
                    
                    async for message in ws:
                        await self._process_websocket_message(message)
                        
            except (websockets.exceptions.ConnectionClosed, 
                    websockets.exceptions.WebSocketException,
                    asyncio.TimeoutError) as e:
                logging.warning(f"WebSocket disconnected: {str(e)[:200]}")
                await asyncio.sleep(reconnect_delay)
                reconnect_delay = min(reconnect_delay * 2, max_reconnect_delay)
            except Exception as e:
                logging.error(f"WebSocket error: {str(e)[:200]}")
                await asyncio.sleep(5)

    async def _process_websocket_message(self, message):
        try:
            data = json.loads(message)
            if data.get('method') != 'transactionNotification':
                return
                
            result = data.get('params', {}).get('result')
            if not result:
                return
                
            price = await self._extract_price_from_transaction(result)
            if price and 1e-8 < price < MAX_REASONABLE_PRICE:
                await self._update_price_data(price, 'websocket')
                self.last_ws_update = datetime.now()
                self.price_update_event.set()
                
        except json.JSONDecodeError:
            logging.warning("Invalid JSON in websocket message")
        except Exception as e:
            logging.error(f"Message processing error: {str(e)[:200]}")

    async def _extract_price_from_transaction(self, transaction_data):
        try:
            message = transaction_data['transaction']['message']
            account_keys = message['accountKeys']
            
            for ix in message['instructions']:
                if ix['programId'] in ['srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX', 
                                      '9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP']:
                    data = base64.b64decode(ix['data'])
                    if len(data) >= 17 and data[0] in [9, 1]:
                        in_amount = int.from_bytes(data[1:9], 'little')
                        out_amount = int.from_bytes(data[9:17], 'little')
                        if in_amount == 0 or out_amount == 0:
                            continue
                            
                        try:
                            sol_index = account_keys.index(SOL_MINT)
                            popcat_index = next(i for i, key in enumerate(account_keys) 
                                               if key == TARGET_MINT)
                            if sol_index < popcat_index:
                                return in_amount / (out_amount / 10**TOKEN_DECIMALS) / 1e9
                            return out_amount / (in_amount / 10**TOKEN_DECIMALS) / 1e9
                        except (ValueError, IndexError):
                            continue
            return None
        except Exception as e:
            logging.error(f"Price extraction error: {str(e)[:200]}")
            return None

    async def backup_price_poller(self):
        while True:
            try:
                if (datetime.now() - self.last_ws_update).total_seconds() > 60:
                    price = await self._get_jupiter_price()
                    if price:
                        await self._update_price_data(price, 'api_poll')
                await asyncio.sleep(30)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logging.error(f"Price polling error: {str(e)[:200]}")
                await asyncio.sleep(30)

    async def _get_jupiter_price(self):
        try:
            async with self.session.get(
                f"{JUPITER_API_BASE}/quote",
                params={
                    "inputMint": SOL_MINT,
                    "outputMint": TARGET_MINT,
                    "amount": int(0.01 * 1e9),
                    "slippageBps": 1000
                },
                timeout=10
            ) as resp:
                data = await resp.json()
                raw_token_amount = float(data.get("outAmount", 0))
                if raw_token_amount <= 0:
                    return None
                    
                price = 0.01 / (raw_token_amount / 10**TOKEN_DECIMALS)
                return price if 1e-8 < price < MAX_REASONABLE_PRICE else None
                
        except Exception as e:
            logging.error(f"Price fetch error: {str(e)[:200]}")
            return None

    async def _update_price_data(self, price, source):
        async with self.price_lock:
            if self.current_price is None:
                self.current_price = price
                logging.info(f"ðŸ’° Initial price set: {price:.6f}")
                
            if price <= 0 or price > MAX_REASONABLE_PRICE:
                return
                
            if self.current_price and abs(price - self.current_price)/self.current_price < 0.0005:
                return
                
            high = low = price
            if self.price_history:
                prev_close = self.price_history[-1]['close']
                high = max(price, prev_close * 1.001)
                low = min(price, prev_close * 0.999)
                
            self.current_price = price
            self.price_history.append({
                'high': high,
                'low': low,
                'close': price,
                'timestamp': datetime.now()
            })
            logging.debug(f"Price update ({source}): {price:.6f}")
            self.popcat_price_gauge.set(price)
            await self.update_metrics()

    async def update_balances(self):
        while True:
            try:
                async with self.balance_lock:
                    sol_resp = await self.client.get_balance(self.keypair.pubkey())
                    sol_balance = sol_resp.value / 1e9
                    token_balance = await self._get_token_balance()
                    
                    self.balance_cache.update({'sol': sol_balance, 'token': token_balance})
                    self.last_balance_update = datetime.now()
                    
                    logging.info(f"ðŸ“Š Balance: {sol_balance:.4f} SOL | {token_balance:.2f} POPCAT")
                    await self.update_metrics()
                    
                await asyncio.sleep(60)
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                logging.error(f"Balance update error: {str(e)[:200]}")
                await asyncio.sleep(30)

    async def _get_token_balance(self):
        try:
            ata = get_associated_token_address(
                Pubkey.from_string(self.wallet),
                Pubkey.from_string(TARGET_MINT)
            )
            payload = {
                "jsonrpc": "2.0", 
                "id": random.randint(1, 10000),
                "method": "getTokenAccountBalance",
                "params": [str(ata), {"commitment": "confirmed"}]
            }
            
            async with self.session.post(
                self.client._provider.endpoint_uri,
                json=payload
            ) as resp:
                result = await resp.json()
                if "result" in result and "value" in result["result"]:
                    return int(result["result"]["value"]["amount"]) / 10**TOKEN_DECIMALS
        
        except Exception as e:
            logging.debug(f"Direct balance check failed: {str(e)[:200]}")
        
        try:
            opts = TokenAccountOpts(mint=Pubkey.from_string(TARGET_MINT), encoding="jsonParsed")
            resp = await self.client.get_token_accounts_by_owner(self.keypair.pubkey(), opts)
            return sum(
                int(acc.account.data.parsed["info"]["tokenAmount"]["amount"]) / 10**TOKEN_DECIMALS
                for acc in resp.value
            )
        except Exception as e:
            logging.warning(f"Fallback balance check failed: {str(e)[:200]}")
            return 0.0

    async def execute_trade(self, input_mint: str, output_mint: str, amount: float):
        if amount <= 0:
            logging.error("Invalid trade amount")
            return False

        current_balance = await self.get_balance(input_mint)
        required = amount + (MIN_SOL_BALANCE if input_mint == SOL_MINT else 0)
        
        if current_balance < required:
            logging.error(f"ðŸš¨ Insufficient funds: {current_balance:.4f} < {required:.4f}")
            return False

        for attempt in range(3):
            try:
                async with self.trade_lock:
                    return await self._attempt_trade(input_mint, output_mint, amount)
            except (aiohttp.ClientError, asyncio.TimeoutError) as e:
                delay = (attempt + 1) * 1.5
                logging.error(f"Network error (retry {attempt+1}/3): {str(e)[:200]}")
                await asyncio.sleep(delay)
            except Exception as e:
                logging.error(f"Trade error: {str(e)[:200]}")
                self.health_monitor.record_error()
                await asyncio.sleep(1)

        logging.error("âŒ Trade failed after all attempts")
        return False

    async def _attempt_trade(self, input_mint: str, output_mint: str, amount: float):
        await self._ensure_associated_token_account()
        
        blockhash_resp = await self.client.get_latest_blockhash(commitment=Confirmed)
        latest_blockhash = blockhash_resp.value
        
        quote = await self._get_jupiter_quote(input_mint, output_mint, amount)
        swap_data = await self._get_swap_data(quote)
        
        tx_bytes = base64.b64decode(swap_data["swapTransaction"])
        signed_tx = self._sign_transaction(tx_bytes)
        
        txid = await self._send_transaction(signed_tx)
        confirmed = await self._confirm_transaction(txid, latest_blockhash)
        
        if not confirmed:
            raise Exception("Transaction confirmation failed")
            
        self._update_post_trade_metrics(output_mint, amount, txid)
        return True

    async def _get_jupiter_quote(self, input_mint, output_mint, amount):
        async with self.session.get(
            f"{JUPITER_API_BASE}/quote",
            params={
                "inputMint": input_mint,
                "outputMint": output_mint,
                "amount": int(amount * (1e9 if input_mint == SOL_MINT else 10**TOKEN_DECIMALS)),
                "slippageBps": 1000,
                "swapMode": "ExactIn" if input_mint == SOL_MINT else "ExactOut"
            },
            timeout=15
        ) as resp:
            return await resp.json()

    def _sign_transaction(self, tx_bytes):
        unsigned_tx = VersionedTransaction.from_bytes(tx_bytes)
        signing_key = SigningKey(base58.b58decode(self.base58_private_key)[:32])
        signature = signing_key.sign(to_bytes_versioned(unsigned_tx.message)).signature
        return VersionedTransaction.populate(unsigned_tx.message, [Signature(signature)])

    async def _send_transaction(self, signed_tx):
        txid = await self.client.send_raw_transaction(
            bytes(signed_tx),
            opts=TxOpts(skip_preflight=False, preflight_commitment=Confirmed)
        )
        return txid.value

    async def _confirm_transaction(self, txid, blockhash):
        return await self.client.confirm_transaction(
            txid,
            blockhash.blockhash,
            blockhash.last_valid_block_height,
            timeout=30
        )

    def _update_post_trade_metrics(self, output_mint, amount, txid):
        direction = "buy" if output_mint == TARGET_MINT else "sell"
        self.trade_count.labels(direction=direction).inc()
        
        if output_mint == TARGET_MINT:
            bought_amount = amount / self.current_price
            self.fifo_queue.append({
                'amount': bought_amount,
                'cost': amount,
                'price': self.current_price,
                'time': datetime.now()
            })
            self.total_invested_sol += amount
            self.total_popcat_bought += bought_amount

        logging.info(f"âœ… Trade success! TX: https://solscan.io/tx/{txid}")

    async def _ensure_associated_token_account(self):
        try:
            ata = get_associated_token_address(
                Pubkey.from_string(self.wallet),
                Pubkey.from_string(TARGET_MINT)
            )
            account_info = await self.client.get_account_info(ata)
            if not account_info.value:
                logging.info("ðŸ›  Creating associated token account")
                ix = create_associated_token_account(
                    payer=self.keypair.pubkey(),
                    owner=self.keypair.pubkey(),
                    mint=Pubkey.from_string(TARGET_MINT)
                )
                await self.client.send_transaction(ix, self.keypair)
                await asyncio.sleep(2)
        except Exception as e:
            logging.error(f"ATA check failed: {str(e)[:200]}")
            raise

    async def calculate_rsi(self):
        if self.rsi_cache[1].date() == datetime.now().date():
            return self.rsi_cache[0]
            
        closes = np.array([p['close'] for p in self.price_history], dtype=np.float32)
        if len(closes) < RSI_PERIOD + 1:
            return None
        
        deltas = np.diff(closes)
        gains = np.maximum(deltas, 0)
        losses = np.minimum(deltas, 0)
        
        avg_gain = np.mean(gains[:RSI_PERIOD])
        avg_loss = -np.mean(losses[:RSI_PERIOD])
        
        with np.errstate(divide='ignore'):
            rs = np.divide(avg_gain, avg_loss, where=avg_loss!=0)
        
        rsi = 100 - (100 / (1 + rs))
        self.rsi_cache = (rsi.item(), datetime.now())
        return rsi

    async def trading_strategy(self):
        initial_price = await self._get_jupiter_price()
        if initial_price:
            await self._update_price_data(initial_price, 'startup')
        
        while len(self.price_history) < RSI_PERIOD + 1:
            logging.info(f"ðŸ“ˆ Collecting price data ({len(self.price_history)}/{RSI_PERIOD + 1})")
            try:
                await asyncio.wait_for(self.price_update_event.wait(), timeout=10)
                self.price_update_event.clear()
            except asyncio.TimeoutError:
                price = await self._get_jupiter_price()
                if price:
                    await self._update_price_data(price, 'startup_poll')
            await asyncio.sleep(5)
        
        logging.info("âœ… Price history collected, starting trading strategy")
        
        while True:
            try:
                if self.health_monitor.reset_daily_pnl():
                    logging.info("ðŸ”„ Daily metrics reset")
                
                if self.health_monitor.daily_pnl < self.health_monitor.MAX_DAILY_LOSS:
                    logging.critical("ðŸ›‘ Daily loss limit reached!")
                    await asyncio.sleep(600)
                    continue
                
                rsi_value = await self.calculate_rsi()
                logging.info(f"ðŸ“Š RSI: {rsi_value:.2f}" if rsi_value else "ðŸ“Š RSI: Calculating...")
                
                if not rsi_value:
                    await asyncio.sleep(15)
                    continue
                
                sol_balance = await self.get_balance(SOL_MINT)
                token_balance = await self.get_balance(TARGET_MINT)
                
                if rsi_value < RSI_OVERSOLD and sol_balance > MIN_SOL_BALANCE:
                    position_size = sol_balance * RISK_PER_TRADE
                    logging.info(f"ðŸš€ Buy signal: {position_size:.4f} SOL at {self.current_price:.6f}")
                    if await self.execute_trade(SOL_MINT, TARGET_MINT, position_size):
                        pass
                
                elif rsi_value > RSI_OVERBOUGHT and token_balance >= MIN_TOKEN_RECEIVED / 10**TOKEN_DECIMALS:
                    sell_amount = token_balance * SELL_PERCENTAGE
                    logging.info(f"ðŸ’° Sell signal: {sell_amount:.2f} tokens at {self.current_price:.6f}")
                    realized_pnl = await self._calculate_realized_pnl(sell_amount)
                    if await self.execute_trade(TARGET_MINT, SOL_MINT, sell_amount):
                        self.realized_pnl.inc(realized_pnl)
                        self.health_monitor.daily_pnl += realized_pnl
                        self.total_popcat_bought -= sell_amount
                        self.total_invested_sol -= (self.current_price * sell_amount - realized_pnl)
                
                await asyncio.sleep(15)
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                logging.error(f"Strategy error: {str(e)[:200]}")
                self.health_monitor.record_error()
                await asyncio.sleep(60)

    async def _calculate_realized_pnl(self, sell_amount):
        if not self.fifo_queue:
            return 0.0
            
        realized = 0.0
        remaining = sell_amount
        
        while remaining > 0 and self.fifo_queue:
            oldest = self.fifo_queue[0]
            if oldest['amount'] <= remaining:
                realized += (self.current_price - oldest['price']) * oldest['amount']
                remaining -= oldest['amount']
                self.fifo_queue.popleft()
            else:
                realized += (self.current_price - oldest['price']) * remaining
                oldest['amount'] -= remaining
                remaining = 0
                
        return realized

    async def cleanup(self):
        try:
            if hasattr(self, 'session') and not self.session.closed:
                await self.session.close()
            if hasattr(self, 'client'):
                await self.client.close()
            logging.info("âœ… Resources cleaned up")
        except Exception as e:
            logging.error(f"Cleanup error: {str(e)[:200]}")

async def main():
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler("trading_bot.log"),
            logging.StreamHandler()
        ]
    )
    
    trader = None
    try:
        trader = RSITrader()
        tasks = [
            asyncio.create_task(trader.listen_for_price_updates(), name="ws_listener"),
            asyncio.create_task(trader.update_balances(), name="balance_updater"),
            asyncio.create_task(trader.backup_price_poller(), name="price_poller"),
            asyncio.create_task(trader.trading_strategy(), name="trading_strategy")
        ]
        
        done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_EXCEPTION)
        
        for task in done:
            if task.exception():
                logging.critical(f"Task failed: {task.get_name()} - {task.exception()}")
                
        for task in pending:
            task.cancel()
            try:
                await task
            except asyncio.CancelledError:
                pass
    
    except KeyboardInterrupt:
        logging.info("ðŸ›‘ Keyboard interrupt received")
    except Exception as e:
        logging.critical(f"Fatal error: {str(e)[:200]}")
    finally:
        if trader:
            await trader.cleanup()
        logging.info("ðŸ Bot shutdown complete")

if __name__ == "__main__":
    asyncio.run(main())
